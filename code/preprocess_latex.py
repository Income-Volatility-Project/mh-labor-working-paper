#!/usr/bin/env python3
# /// script
# requires-python = ">=3.8"
# ///
"""
LaTeX Preprocessor - Replace \\input commands with table contents

This script processes a LaTeX file and replaces \\input{...} commands that reference
tables with the actual contents of those files. Figure inputs are left unchanged.

Usage:
    python preprocess_latex.py [input_file]
    uv run preprocess_latex.py [input_file]

Default input file: ../manuscript/vip_JDE_SI_R2.tex
Output: Creates a new file with _preprocessed suffix
"""

import re
import sys
from pathlib import Path


def is_table_input(input_path: str) -> bool:
    """
    Determine if an \\input command refers to a table (not a figure).

    Args:
        input_path: The path from the \\input{...} command

    Returns:
        True if this appears to be a table, False otherwise
    """
    # Convert to lowercase for case-insensitive matching
    path_lower = input_path.lower()

    # Check if it's explicitly a figure (skip these)
    if any(keyword in path_lower for keyword in ['figure', 'fig_', '/figures/']):
        return False

    # Check if it's explicitly a table (include these)
    if any(keyword in path_lower for keyword in ['table', 'tab_', '/tables/']):
        return True

    # If neither, default to including it (conservative approach)
    # You can change this to False if you want to be more restrictive
    return True


def process_latex_file(input_file: Path) -> Path:
    """
    Process a LaTeX file and replace table \\input commands with file contents.

    Args:
        input_file: Path to the input LaTeX file

    Returns:
        Path to the output (preprocessed) file
    """
    # Read the input file
    with open(input_file, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    # Prepare output
    output_lines = []
    input_dir = input_file.parent

    # Add generated comment to output lines
    output_lines.append("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n")
    output_lines.append("% DO NOT EDIT BY HAND\n")
    output_lines.append(f"% GENERATED BY SCRIPT FROM {input_file.name}\n")
    output_lines.append("% Please update that file and regenerate to avoid inconsistencies\n")
    output_lines.append("% Script for generating can be found in [replication package](https://github.com/Income-Volatility-Project/mh-labor-working-paper)\n")
    output_lines.append("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n")

    # Regular expression to match \input{...} commands
    # Handles both \input{file} and \input{file.tex}
    input_pattern = re.compile(r'^\s*\\input\{([^}]+)\}')

    replaced_count = 0
    skipped_count = 0

    for line_num, line in enumerate(lines, 1):
        match = input_pattern.match(line)

        if match:
            # Extract the file path from \input{...}
            input_path = match.group(1)

            # Add .tex extension if not present
            if not input_path.endswith('.tex'):
                input_path_with_ext = input_path + '.tex'
            else:
                input_path_with_ext = input_path

            # Check if this is a table input
            if is_table_input(input_path):
                # Resolve the path relative to the input file's directory
                table_file = input_dir / input_path_with_ext

                try:
                    # Read the table file
                    with open(table_file, 'r', encoding='utf-8') as f:
                        table_content = f.read()

                    # Add comment indicating the replacement
                    output_lines.append(f"% Original: \\input{{{input_path}}}\n")
                    output_lines.append(f"% File: {table_file.relative_to(input_file.parent)}\n")
                    output_lines.append(f"% --- BEGIN INLINED CONTENT ---\n")
                    output_lines.append(table_content)
                    if not table_content.endswith('\n'):
                        output_lines.append('\n')
                    output_lines.append(f"% --- END INLINED CONTENT ---\n")

                    replaced_count += 1
                    print(f"✓ Replaced: {input_path} (line {line_num})")

                except FileNotFoundError:
                    # If file not found, keep the original \input command
                    output_lines.append(line)
                    print(f"✗ File not found: {table_file} (line {line_num}) - keeping original")
                    skipped_count += 1

            else:
                # This is a figure or other input - keep original
                output_lines.append(line)
                print(f"○ Skipped (figure/other): {input_path} (line {line_num})")
                skipped_count += 1
        else:
            # Not an \input command - keep as is
            output_lines.append(line)

    # Create output filename with _preprocessed suffix
    output_file = input_file.parent / f"{input_file.stem}_preprocessed{input_file.suffix}"

    # Write the output file
    with open(output_file, 'w', encoding='utf-8') as f:
        f.writelines(output_lines)

    print(f"\n{'='*60}")
    print(f"Summary:")
    print(f"  Tables replaced: {replaced_count}")
    print(f"  Inputs skipped: {skipped_count}")
    print(f"  Output file: {output_file}")
    print(f"{'='*60}")

    return output_file


def main():
    """Main entry point for the script."""
    # Default input file
    default_file = Path(__file__).parent.parent / "manuscript" / "vip_JDE_SI_R2.tex"

    # Get input file from command line or use default
    if len(sys.argv) > 1:
        input_file = Path(sys.argv[1])
    else:
        input_file = default_file

    # Check if input file exists
    if not input_file.exists():
        print(f"Error: File not found: {input_file}", file=sys.stderr)
        sys.exit(1)

    print(f"Processing: {input_file}")
    print(f"{'='*60}\n")

    # Process the file
    try:
        output_file = process_latex_file(input_file)
        print(f"\n✓ Successfully created: {output_file}")
    except Exception as e:
        print(f"\n✗ Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
